/**
 * Алгоритм модульной инверсии используется для нахождения обратного элемента по модулю, то есть числа, умножение на
 * которое даст 1 по модулю
 * <p>
 * Некоторые области применения:
 * нахождение НОД (Наибольший общий делитель);
 * криптография, например, криптография с открытым ключом и алгоритм RSA;
 * теория чисел и другие области, где необходимо решать уравнения вида ax + by = gcd(a, b) или ax ≡ 1 (mod m)
 * Также модульная мультипликативная инверсия нужна, чтобы деобфусцировать идентификаторы, то есть вернуть их исходное
 * значение. Например, в алгоритме кодирования и декодирования чисел
 * <p>
 * Для вычисления модульных мультипликативных обратных чисел можно использовать расширенный алгоритм Евклида.
 * Алгоритм модульной инверсии используется для решения проблемы столкновений в компьютерной графике. Этот метод позволяет
 * быстро находить объекты, находящиеся в непосредственной близости друг от друга, тем самым предотвращая их пересечение
 * или столкновение
 */
public class ModularInverse {

    public static int modularInverse(int a, int n) {
        int[] rxy = extendedEuclid(a, n);
        if (rxy[0] != 1) {
            return 0;
        } else if (rxy[1] < 0) {
            return rxy[1] + n;
        } else  {
            return rxy[1];
        }
    }

    public static int[] extendedEuclid(int a, int n) {
        if (n == 0) {
            return new int[]{a, 1, 0};
        } else {
            int[] rxy = extendedEuclid(n, a % n);
            int tmp = rxy[1] - rxy[2] * (a / n);
            rxy[1] = rxy[2];
            rxy[2] = tmp;
            return rxy;
        }
    }
}
