import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class LZWDecompress {

    public static String lzwDecompress(int[] compressed, int nb, int n) {
        int maxCode = (int) Math.pow(2, nb) - 1; // Возможные значения кодирования
        Map<Integer, String> dt = new HashMap<>();
        for (int i = 0; i < n; i++) {
            dt.put(i, (char) i + "");
        }
         /*
            code - Начальное число для предосталение групп из двух или более букв. 0-127 - для предоставления униграмм,
            128-255 - для продоставления n-грамм > 1
         */
        int code = n / 2;
        String decompressed = "";
        /*
            Чтобы запустить процесс развертывания сам по себе, мы берем первую кодировку (строчка 7), убираем ее
            из списка и ищем в таблице декодирования
         */
        int c = compressed[0];
        compressed = Arrays.copyOfRange(compressed, 1, compressed.length);
        String v = dt.get(c);

        decompressed += v;
        String pv = v; // Последнее значение развертывания
        for (Integer c1 : compressed) {
            v = dt.get(c1);
            if (v == null) {
                /*
                    LZW-развертывании тупиковая ситуация случается, когда во время сжатия мы создаем n-грамму и тут же
                    выводим результат. Такая ситуация показана на рисунке deadlock.png(a). Мы сжимаем строку ABABABA. Шифруем
                    AB, затем BA, а потом ABA, чья кодировка как раз и является нашим следующим результатом. Сжатый итог
                    представляет собой список [65, 66, 128, 130]. Если нам нужно развернуть список [65, 66, 128, 130],
                    мы начинаем с числа 65, которое, согласно таблице dt, равно A; посмотрите на рисунок deadlock.png(b).
                    Затем мы берем число 66, которым зашифровано B. Мы добавляем в таблицу декодирования биграмму AB,
                    ключом которой служит значение 128. Далее берем из списка 128, которое при развертывании становится AB.
                    Последним берем значение 130; 130 еще не добавлено в таблицу декодирования.Чтобы уладить проблему,
                    нам нужно вернуться на шаг назад и вспомнить, что такое случается, только когда в процессе кодирования
                    мы что-то шифруем и тут же выводим результат этого шифрования. Предположим, мы прочли строку x[0],x[1],…,x[k],
                    которую мы нашли в таблице декодирования. Затем мы чита-ем x[k + 1] и не можем найти x[0],x[1],…,x[k],x[k + 1]
                    в таблице. Мы сжимаем x[0],x[1],…,x[k], используя ее кодировку, а затем создаем новую кодировку для
                    x[0],x[1],…,x[k],x[k + 1]. Если следующее, что мы сжимаем, как раз x[0],x[1],…,x[k],x[k + 1], тогда
                    процесс возможен только, если вводимые строки имеют вид:… x[0] x[1] … x[k] x[k + 1] x[k] x[1] … x[k] x[k + 1] …
                    Иными словами, x[0] = x[k +1] и новая, только что созданная n-грамма равны предыдущей n-грамме с ее
                    первым символом, добавленным в конец. Что и отображено на deadlock.png
                 */
                v = pv + pv.charAt(0);
            }
            decompressed += v;
            if (code <= maxCode) {
                dt.put(code, pv + v.charAt(0));
                code += 1;
            }
            pv = v;
        }
        return decompressed;
    }
}
